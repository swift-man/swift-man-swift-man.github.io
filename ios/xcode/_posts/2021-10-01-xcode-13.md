---
sidebar:
  title: "iOS"
  nav: sidebar-ios
  icon: "fab fa-app-store-ios"
title: "Xcode 13.0"
toc: true
toc_sticky: true
toc_label: 목차
tag: "Xcode"
published : false
depth:
  - title: "iOS"
    url: /ios/
    icon: "fab fa-app-store-ios"
  - title: "Xcode"
    url: /ios/xcode/
    icon: "far fa-folder-open"
---
구글 번역기로 돌린 번역입니다. 잘못된 오역이 있음을 주의하여 주세요.👀

[<i class="fas fa-link"></i> Xcode 13 소개 페이지](https://developer.apple.com/kr/xcode/){:target="_blank"}

# Xcode 13
Xcode 13에는 Swift 5.5와 iOS 15, iPadOS 15, macOS Monterey, tvOS 15, watchOS 8용 SDK가 포함되어 있습니다.

## Xcode
* Xcode UI는 새로운 내비게이터 아이콘과 새로운 상시표시형 하단 막대로 세분화되었습니다.
* Report(보고) 내비게이터의 새로운 Cloud(클라우드) 탭에 Xcode Cloud 작업 흐름 및 빌드 결과가 표시됩니다.

## Xcode Cloud
* Xcode 속에 내장된 클라우드 기반 도구를 사용하여 앱을 빌드하고, 테스트하고, 전달할 수 있습니다.
* 클라우드에서 테스트를 병렬로 실행하고, Report(보고) 내비게이터에서 결과를 확인할 수 있습니다.
* App Store Connect에서 작업 흐름을 보고 편집하고, 빌드 결과를 확인할 수 있습니다.
* TestFlight를 사용하여 테스터에게 빌드를 자동으로 배포할 수 있습니다.

## 소스 코드 관리 통합
* 완전히 새로워진 Pull Request 경험을 통해 소스 코드 변경 사항의 검토 과정을 Xcode에 긴밀하게 통합합니다.
* 코드 검토 모드에는 새로운 인라인 비교 모드가 포함되어 있어 현재의 편집 컨텍스트에서 바로 비교 보기가 가능합니다.
## 테스트
* 반복 테스트를 통해 테스트에 실패할 때까지 또는 통과할 때까지 테스트를 실행하거나 실패율 데이터를 수집할 수 있도록 지정된 횟수만큼 테스트를 실행할 수 있습니다.
* XCTest는 메모리 추적 및 iPadOS 커서 상호 작용 테스트를 지원합니다.

## 편집기
* Swift 코드 완성이 더 빠르고 더 강력해졌습니다.
* Swift 구문 하이라이트 기능을 더 빠르고 안정적으로 이용할 수 있습니다.

## 디버깅
* 열 바꿈으로 하위 줄 바꿈 변환이 가능합니다.
* 선택적 셰이더 디버거를 사용하여 더 큰 셰이더 내에서 디버깅할 기능을 선택할 수 있어, 큰 셰이더의 처리 절차를 반복하고 디버깅하는 데 소요되는 시간을 줄일 수 있습니다.

## 기타 개선 사항
* TestFlight에 있는 앱의 충돌 보고서가 수 분 내로 Xcode Organizer에 표시되며, 사용자 피드백을 포함할 수 있습니다.
* Xcode 편집기는 Vim 사용자에게 친숙한 여러 가지 일반적인 키 조합 및 편집 모드를 지원합니다.
* Instruments에서 Metal에 의해 가속화된 새로운 GPU 타임라인 보기를 사용하면 대량 추적 정보에도 매끄럽게 상호 작용합니다.
* Instruments의 CPU 프로프일러 템플릿에서 주기 기반 프로파일링을 사용할 수 있습니다.
* 새로운 HTTP 네트워크 추적 도구를 통해 개발자 및 개인정보 보호 연구자는 HTTP 기반 네트워크 트래픽을 디버깅하고 분석할 수 있습니다.


# Xcode 13 Release Notes
Update your apps to use new features, and test your apps against API changes.

## Overview
Xcode 13에는 iOS 15, iPadOS 15, tvOS 15, watchOS 8 및 macOS Big Sur 11.3용 SDK가 포함되어 있습니다. Xcode 13 릴리스는 iOS 9 이상, tvOS 9 이상, watchOS 2 이상에 대한 온디바이스 디버깅을 지원합니다. Xcode 13을 사용하려면 macOS 11.3 이상을 실행하는 Mac이 필요합니다.

## General
### New Features
* Xcode 13에는 [<i class="fas fa-link"></i> Swift 를 사용한 동시성 프로그래밍](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html){:target="_blank"}에 대한 기본 지원, [<i class="fas fa-link"></i> Xcode Cloud](https://developer.apple.com/xcode-cloud/){:target="_blank"}와의 지속적인 통합 및 전달 지원, Git pull 요청에 대한 통합 지원, DocC를 사용하여 Swift 프레임워크에서 문서를 생성하고 볼 수 있는 기능, Vim 키 바인딩 지원, Swift 패키지 컬렉션 등을 지원합니다.(78887232)
* 이제 cktool command line에서 cktool을 사용하여 [<i class="fas fa-link"></i> CloudKit](https://developer.apple.com/documentation/cloudkit){:target="_blank"} database schema 및 records 와 상호 작용할 수 있습니다. 사용 가능한 명령 목록을 보려면 `run man cktool ` 또는 `xcrun cktool --help`를 실행하십시오.(68114031)
* 이제 command line에서 TextureConverter 사용 하여 textures를 모든 Metal compressed texture formats으로 압축할 수 있습니다. 사용 가능한 명령 목록을 보려면 `TextureConverter --help`를 실행하십시오. (70481436)
* Xcode 13의 XIP archive는 이제 동일한 콘텐츠에 대해 약 15% 더 작아졌습니다. archive Utility를 사용하거나 xip command line 에서 archive를 expand 할 수 있습니다. Note: archive를 expanding하는 다른 방법으로 인해 Xcode 앱이 손상될 수 있습니다. (78714333)

### Resolved Issues
Xcode의 Keyboard shortcuts는 이제 documentation window에 탭이 두 개 이상 열려 있거나 full-screen mode일 때 예상대로 작동합니다. (72209603) (FB8936285)

## Apple Clang Compiler
### New Features
* new Swift concurrency model을 지원하기 위해 clang이제 completion handler를 두 번 이상 호출하거나 실행 경로에 완료 핸들러 호출이 없는 경우 경고할 수 있습니다. new Warnings를 켜려면 Apple Clang - Warnings - All languages section의 project’s Build Settings에서 Completion Handler Misuse pop-up menu를 Yes를 선택합니다. 또는 clang command line에서 호출할 때 `-Wcompletion-handler flag`를 전달합니다. 메서드에 `NS_SWIFT_DISABLE_ASYNC` 속성을 추가하여 메서드에 대한 경고를 표시하지 않을 수 있으며, 이것은 또한 이 메서드를 Swift에서 async 메서드로 변환하는 것을 억제합니다. (10708075)
* The new `-fobjc-constant-literals flag` 사용하면 전역 상수 literals을 선언하고, Objective-C 코드에서 지원하는 다른 literals에 대한 optimizations를 수행할 수 있습니다. 이 flag를 사용 하여 compile time에 embed static property list literals(NSDictionary, NSNumber, and NSArray)를, binaries의 CONST 섹션에 배치합니다. (44920795, 45380392)<br/><br/>
  For example:
  ```swift
  static NSString * const MyNotificationName = @"MyNotification";
  ```
  <br/>
  And:
  ```swift
  static NSDictionary * const myConstantDictionary = @{ @"something_awesome" : @YES };
  static NSArray * const myArray = @[ @1, @2, @3, @4 ];
  static NSNumber * const answerToLife = @42
  ```
  <br/>
  가능한 경우 compiler는 위의 예와 유사하지만 non-global scope에 있는 명령문도 변환합니다.<br/>
  <br/>
  컴파일러는 macOS 11, iOS 및 iPadOS 14, tvOS 14, watchOS 7 이상의 deployment targets에서 이 플래그를 지원합니다. 플래그는 기본적으로 활성화되어 있습니다. 상수 리터럴을 완전히 비활성화하려면 `-fno-objc-constant-literals`를 사용합니다. 특정 상수 리터럴 최적화를 선택적으로 비활성화하려면 `-fno-constant-nsnumber-literals, -fno-constant-nsarray-literals` 및 `-fno-constant-nsdictionary-literals`를 사용합니다.<br/>
  <br/>
  plutil tool은 macOS 11 이상에서 사용할 수 있으며, constant section cbjective-c literals을 사용하여 소스 파일을 생성할 수 있습니다. 예를 들어 다음 명령을 사용하여 .m 파일을 생성할 수 있습니다.
  ```
  plutil -convert objc SomePlist.plist
  ```
  <br/>
  .m 파일을 따르는 .h헤더 파일 을 생성하려면 -header 다음 명령과 같이 선택적 플래그를 추가합니다.
  ```
  plutil -convert objc -header SomePlist.plist
  ```
  <br/>
  Note: In constant dictionaries는 NSString키로 만 사용할 수 있습니다. 다른 유형을 사용하면 오류가 발생합니다.
  ```swift
  // This throws an error, the initializer element isn't a compile-time constant.
  static NSDictionary * const myConstantDictionary = @{ @42 : @@"answer to life" }; 
  ```
* 이제 Xcode의 빌드 설정에서 C++20및 GNU++20C++ language dialects를 구성할 수 있습니다. (50900425)
* clang은 이제 C++20 likelihood attributes 인 [[likely]], [[unlikely]]을 지원합니다.

### Known Issues
* ASAN으로 인해 x86_64에서 Swift async functions가 crash가 발생할 수 있습니다. (80786596)

## Asset Catalogs
### New Features
* runtime 시 앱은 이제 자산 카탈로그의 iOS 앱 아이콘 자산을 대체 앱 아이콘으로 사용할 수 있습니다. new build 에서 "`Include all app icon assets,`"는 Xcode가 빌드된 제품에 모든 앱 아이콘 세트를 포함하는지 여부를 제어합니다. 설정이 비활성화된 경우, Xcode에는 새 설정인 "`Alternate app icon sets.`"에 지정된 아이콘과 함께 기본 앱 아이콘이 포함됩니다. asset catalog compiler는 빌드된 제품의 Info.plist에 적절한 콘텐츠를 삽입합니다. (33600923)
* asset catalog를 통해 watchOS를 포함한 모든 플랫폼에서 사용할 수 있는 universal system colors를 선택할 수 있습니다.(73257675)

## Build System
### New Features
* Configuration settings(.xcconfig) 파일은 이제 \여러 줄에 걸쳐 긴 목록을 나누는 데 `\` 사용 을 지원 합니다.  (4405473) (FB5943765)<br/>
  <br/>
  For example:
  ```
  HEADER_SEARCH_PATHS = $(SRCROOT)/include \
      $(SRCROOT)/include/component1 \
      $(SRCROOT)/include/component2
  ```

* -xcconfig command-line와 `XCODE_XCCONFIG_FILE` 환경 변수를 사용하여 xcconfig 파일을 xcodebuild에 전달할 때, Xcode는 조건 매개변수도 지원하는 New Build System semantics을 사용하여 구문 분석합니다. (25001734)
* `SUPPORTED_PLATFORMS` 빌드 설정을 지원하는 platforms 목록으로 설정 하려면, `ALLOW_TARGET_PLATFORM_SPECIALIZATION`을 YES로 설정하여 단일 빌드 작업에서 multiple platforms에 대해로 빌드하도록 프레임워크를 구성합니다. (45951215)
* 이제 지원되는 모든 플랫폼에 대한 빌드 단계 및 대상 종속성에서 플랫폼 필터를 사용할 수 있습니다. (72240935)
* xcodebuild는 이제 빌드 실패가 발생할 때 빌드 로그 끝에 있는 요약에 실패한 각 명령의 대상 및 프로젝트 이름을 표시합니다. (75081458)
* 이제 build system은 script phase, 또는 custom build rule이 빌드 입력에 속하지 않고, 빌드의 다른 작업의 output dependency로 선언되지 않은 input dependency를 선언하면 경고를 내보냅니다. (76129954)
* build options sheet에 `Parallelize Build option`을 대체하는 `Dependency Order option`과 deprecated 되었으나 레거시 호환성을 위해 포함된 `Manual Order option`이 포함되어 있습니다. (76251439)

### Resolved Issues
* iOS 및 iPadOS, tvOS 및 watchOS SDK에 대해 빌드할 때 `NATIVE_ARCH` 빌드 설정을 armv7로 설정하는 문제를 수정했습니다. `NATIVE_ARCH` 빌드 설정은 이제 호스트 Mac의 아키텍처 제품군(Apple 실리콘이 있는 Mac의 arm64 또는 Intel 기반 Mac의 x86_64)을 반영합니다. (5716560)
* iOS, tvOS 또는 watchOS용으로 빌드할 때 framework target 에서 XCTest 또는 StoreKitTest 가져오기 시 linker error 발생 오류가 발생하지 않습니다. (61952138)
* "redefinition of module" 오류가 발생할 수 있는 public and private module maps이 있는 frameworks와 관련된 dependency ordering issue를 수정했습니다. (72123120)
* issue navigator 에서 warning 또는 error를 클릭해도 연결된 C 또는 C++ 파일로 이동하지 않는 문제가 수정되었습니다. (73582669) (FB8981116)
* build system service crashed가 발생된 경우 workspace를 닫았다가 다시 열어야 하는 문제가 수정되었습니다. 이제 workspace에서 다시 빌드를 시도할 수 있습니다. (74124183)

### Deprecations
* legacy build system은 deprecated 되었으며 사용하려고 하면 오류가 발생합니다. (76124672)

## Core Data
### New Features
* Core Data model editor’s의 attribute inspector에 있는 Allows Cloud Encryption의 checkbox를 사용하여 CloudKit Encrypted Record Fields 기능을 지원합니다. (73670355)

## Core ML
### New Features
* Xcode의 Core ML model editor는 이제 metadata 및 package format과 함께 새로운 Core ML 패키지 형식인 .mlpackage를 지원합니다. model들의 Utilities tab에서 Core ML model을 .mlmodel 형식에서 .mlpackage 형식으로 업그레이드할 수 있습니다. (69867656)
* 이제 Swift에서 생성한  Core ML models interface는 배포 대상이 macOS 12, iOS 15, tvOS 15 또는 watchOS 8인 경우 강력한 형식의 `MLShappedArray` properties를 통해 다차원 입력 및 출력에 대한 액세스를 포함됩니다. (73627777)

### Resolved Issues
* macOS 11 에서 CoreML 모델 패키지의 preview 탭이 응답하지 않거나 "Unable to compile model at <ModelName>.mlpackage" 오류의 문제가 해결되었습니다. (77794983)
* class labels가 없는 ML Program format의 ML Packages를 Xcode editor에서 model을 볼 때 operation distribution table이 General tab에 나타나지 않는 문제를 해결했습니다. (78577088)

### Known Issues
* macOS Monterey에서 실행할 때 ML 앱 머신러닝 모델 학습 성능이 예기치 않게 저하될 수 있습니다. (82415543)
* training progress가 계속 실행되는 동안 Create ML 앱을 종료하거나 프로젝트를 닫으면 training 진행 상황이 손실될 수 있습니다. (82460651)  
  해결 방법: 앱을 종료하거나 프로젝트를 닫기 전에 교육을 일시 중지합니다.

## Create ML
### New Features
* 손 포즈를 해석하는 새로운 templates인 training models 사용할 수 있습니다. (68942553)
  * 손 포즈 분류는 image에서 static 손 포즈를 분류하기 위한 model을 training합니다.
  * 손 동작 분류는 video에서 dynamic 손 액션들을 분류하기 위한 model을 training합니다.
* 사운드 분류 templates의 Audio Feature Print option을 사용하면 sound classifier models을 더 높은 정확도, lower latency 및 smaller model size로 더 빠르게 교육할 수 있습니다. 이것은 이제 새 모델 소스에 대한 기본 기능 추출 옵션입니다.  (70558475)

## Debugging
### New Features
* 이제 Xcode의 콘솔은 `Editor > Wrap Lines` menu item을 통한 Line 전환을 지원합니다. (3669727)
* column breakpoint on a line을 설정하려면 Command-click을 클릭한 다음 Actions 메뉴에서 Set Column Breakpoint 설정을 선택합니다. (10112530)
* 만약 debugger에서 breakpoint를 해결하지 않은 경우 breakpoint’s icon이 placeholder glyph으로 변경됩니다. symbolic breakpoint과 같은 일부 breakpoints의 경우 연결된 공유 라이브러리가 프로세스에 로드되면 original glype 아이콘으로 다시 변경됩니다. (11439048)

### Resolved Issues
* "debug memory graph" 버튼을 클릭하면 Xcode가 "Building Memory Graph"라는 창을 무한 표시되는 문제를 해결했습니다. 이제 Xcode는 메모리 그래프 검색을 실패하게 하는 모든 오류를 즉시 표시합니다. (59479311)
* Debug > Simulate MetricKit Payloads을 선택하면 이제 macOS, macOS "Designed for iPad" 또는 Mac Catalyst 실행 대상에서 실행 중인 앱을 debugging할 때 작동합니다. (78026869)

### Deprecations
* LLDB의 Python 스크립팅은 더 이상 Python 2를 지원하지 않습니다. (73956573)

## Documentation
### New Features
* Xcode는 Swift 코드의 주석과 함께 동봉된 문서를 생성할 수 있습니다. (57148915, 57446055, 57447632, 74951110)  
  “Build Documentation” command을 사용하여 Swift frameworks 및 packages에서 문서를 생성합니다. `xcodebuild docbuild` command를 사용하여 command-line에서 빌드합니다. 문서 작성에 대한 자세한 사항은 [<i class="fas fa-link"></i> Documenting a Swift Framework or Package](https://developer.apple.com/documentation/Xcode/documenting-a-swift-framework-or-package)를 참조하세요.

  documentation window에서 작성된 문서를 보고 DocC 아카이브 형식을 사용하여 내보냅니다. Xcode는 DocC Archive format을 열고 읽을 수 있습니다. Xcode can open and read DocC Archive packages. 자세한 사항은 [<i class="fas fa-link"></i> Distributing Documentation to External Developers.](https://developer.apple.com/documentation/Xcode/distributing-documentation-to-external-developers)를 참조하세요.

* 코드 완성은 project documentation을 작성할 때 제안 사항을 제공합니다. 소스 파일에 documentation 주석을 작성할 때와 .docc catalog 내에 마크업 파일을 작성할 때 제안을 제공합니다. (57447419)
* Quick Help는 이제 DocC를 사용하여 project documentation을 표시하고 documentation window에서 프로젝트 문서에 대한 링크를 렌더링합니다. (71913824)

### Resolved Issues
* protocol 준수에서 상속된 symbols에 대한 링크가 이제 Quick Help에서 올바르게 확인되고 완료 항목으로 표시됩니다. (76927387)
* documentation viewer의 이동 경로는 이제 콘텐츠 보기 내에서 렌더링된 페이지를 일관되게 반영합니다. (78512655) (FB9118964)

### Known Issues
* bridging header를 사용하여 Swift에 노출된 Objective-C 유형에 대한 링크는 Quick Help에서 확인할 수 없으며 완료 항목으로 표시되지 않습니다. 이 링크는 full documentation builds와 Xcode의 documentation window에서 예상대로 해결됩니다. (77472074)

## Indexing
### New Features
* Xcode는 macro names을 인덱싱합니다. 이제 Open Quickly에 나타납니다. (47815401) (FB5667927)

### Resolved Issues
* Xcode 편집기에서 의미론적 기능(live issues 및 code completion과 같은)을 제공하는 소스 언어 서비스의 신뢰성과 성능을 개선했습니다. (71098549)
  * 신뢰성이 향상되고 빌드가 성공한 사례를 해결했지만 editor에서 예기치 않은 live issues가 발생했습니다.
  * 현재 파일에 반영된 다른 모듈의 소스 파일 변경 내용을 보려면 수동으로 빌드해야 하는 문제를 해결했습니다. Xcode는 이제 백그라운드에서 필요한 업데이트를 전파합니다.
  * XCBBuildService 프로세스가 source languages service의 requests를 처리하는 동안 성능이 향상되고 CPU 사용량이 크게 감소했습니다.
* source modules에 대한 symlinks 있는 Swift package가 Xcode에서 live issues 및 code completion을 중단시키는 문제가 수정되었습니다. (75732781)

## Instruments
### New Features
* 이제 toolbar’s의 Activity viewer의 Run’s Info popover를 사용하여 실행 label을 지정할 수 있습니다. (20823928)
* 이제 Instruments의 Call tree views 및 extended detail view가 "[inlined]" 마커로 인라인 기능을 표시합니다. (36153516)
* detail view navigation bar을 통해 더 보기를 더 쉽게 검색할 수 있습니다. 이제 shortcuts(Command-1, Command-2 등)를 통해 Detail views에 액세스할 수 있습니다. 이제 View menu에서 Run Issues 및 Console views에 액세스할 수 있습니다. (45734644)
* command line에서 `xctrace export`를 사용하여 Allocations, Leaks 및 VM Tracker instruments를 포함하는 table data를 내보낼수 있습니다. 목차에 이 기능이 어떻게 반영되는지 보려면 `run xctrace export --toc`를 실행하십시오. (54600972)
* Instruments extended detail view는 이제 관련 detail view row를 선택할 때 `os_log` 및 `os_signpost` 메시지와 backtraces을 표시합니다. (63098516, 72104089) (FB7697641)
* 이제 Instruments toolbar의 activity view area에 Run Information view가 나타납니다. (65694190)
* 이제 CPU Counters template의 안정성과 성능이 향상되었습니다. Instruments 13은 이전 버전의 Instruments로 기록된 Counters traces을 더 이상 지원하지 않습니다. (65812748)
* leaks command는 `-referenceTree`, `-autoreleasePools` 및 `-debug`의 세 가지 새로운 모드가 있습니다. 자세한 내용은 `man leaks`에 을 찾으세요. (68724178)
* 이제 Network template에 HTTP traffic을 capturing, analyzing하기 위한 새로운 Instrumen가 포함됩니다. 이 Instrumen는 모든 Apple platforms에서 작동하며 다음을 보여줍니다:
  * out-of-process background traffic을 포함하여 debuggable processes에 대한 [<i class="fas fa-link"></i> CFNetwork](https://developer.apple.com/documentation/cfnetwork)){:target="_blank"} layer의 HTTP traffic
  * 각 [<i class="fas fa-link"></i>URLSessionTask](https://developer.apple.com/documentation/foundation/urlsessiontask){:target="_blank"}, 기본 HTTP transactions 및 transaction states에 대한 자세한 기간
  * `URLSessionTasks`에 대한 Backtraces는 code에서 task가 어디서 시작되는지 표시
  * HTTP requests, responses의 Headers 및 본문
  * VPN, Proxies를 통한 traffic, certificate pinning을 사용하여 전송되는 traffic
  
  새로운 `--har` 내보내기 플래그를 사용하여 `xctrace`를 통해 이 HTTP data를 HTTP Archive로 내보낼 수 있습니다. (71444535)
* 이제 Instruments timeline view에서는 Metal 기반 렌더러를 사용하여 timeline 사용성이 전반적으로 향상되는 등 보다 부드러운 환경을 제공합니다. (73591705)
* `os_signpost` Instrument의 recording settings은 이제 recording에 `dynamicTracing` 및 `dynamicStackTracing` logging categories에 대한 `os_signpost` 하위 시스템 지정을 지원합니다. (73694990)
* 새로운 CPU Profiler template을 사용하면 PMI(Cycle-Based Performance Monitoring Interrupts)를 사용하여 CPU workloads를 analyzing할 수 있습니다. 실행되는 코드 또는 Efficiency CPU에 대해 보다 안정적으로 측정할 수 있습니다. (76889185)
* macOS Monterey 및 iOS 15에서 생성된 새로운 JSON-format crash logs를 지원하기 위해 Instruments에는 새 `CrashSymbolicator.py` script가 포함되어 있습니다. 이 Python 3 script는 JSON-format logs에 대한 `symbolatecrash` 유틸리티를 대체하고 기본 옵션으로 inlined frames을 지원합니다. 자세한 내용은 CrashSymbolicator.py --help를 참조하세요. CrashSymbolicator.py는 Xcode 13 내의 Contents/SharedFrameworks/CoreSymbolicationDT.framework/Resources/ 하위 디렉토리에 있습니다. (78891800)

### Resolved Issues
* Xcode에서 arguments를 변경하고 프로필 작업을 호출할 때 기존 trace document를 재사용하지 않는 문제가 수정되었습니다. (41842858)
* 대규모 static archives로 구축된 프로세스를 대상으로 할 때 `malloc_history`와 같은 command-line tools의 성능이 최대 300배 향상되었습니다. (63114609) (FB7698032)
* 이제 Instruments는 DWARF 데이터를 사용할 수 있을 때 backtraces에서 inlined frames을 보다 안정적으로 표시합니다. (74351555)
* 느리거나 응답하지 않는 장치가 연결되어 있을 때 Instruments의 실행 안정성이 향상되었습니다. (77151140)
* 이제 tvOS 15’s Control Center에서 Instruments에서 시작된 HTTP Traffic recording을 중지할 수 있습니다.. (77274053)

### Deprecations
* Instruments는 더 이상 Energy template이 포함되지 않습니다. 대신 Xcode Organizer에서 metrics reporting을 사용하십시오. (74161279)
* deprecated instruments command-line tool이 제거되었습니다. 대신 `xctrace`를 사용하십시오. (74412969)

## Interface Builder
### New Features
* 이제 outline view에서 Storyboard scenes을 수동으로 재정렬할 수 있습니다. (10103709)
* macOS용 Storyboards 및 XIBs는 UINibEncoder를 사용하여 compile하여 file sizes를 줄이고 runtime performance를 개선합니다. macOS 10.13 이전의 앱을 배포할 때 Xcode는 이전 OS들에 대해 이전 버전과 호환되는 nib을 생성합니다. 이 동작을 수행하지 않으려면 project’s build setting의 user defined `IBC_COMPILER_USE_NIBKEYEDARCHIVER_FOR_MACOS=YES` 및 `IBSC_COMPILER_USE_NIBKEYEDARCHIVER_FOR_MACOS=YES` 재정의합니다. (31889616)<br/><br/>
  UINibEncoded nibs는 [<i class="fas fa-link"></i> initWithCoder:](https://developer.apple.com/documentation/foundation/nsnotification/1412464-initwithcoder){:target="_blank"} 구현에서 self 반환이 implementation된custom class에 적용하는 데 더 엄격합니다. `initWithCoder:`에서 nonsafe pointer를 return하는 것은 안전하지 않으며 dangling pointer 참조로 이어질 수 있습니다. macOS 12는 runtime nib load중 이러한 문제가 발생하면 descriptive warning를 표시합니다. 이전 macOS 버전은 "This coder requires that replaced objects be returned from initWithCoder:"를 내보냅니다. 필요한 경우 위에서 설명한 user defined overrides를 적용하여 strictness warning를 무시할 수 있습니다.
* 이제 키보드를 사용하여 "Constraints,"과 같은 navigate outline view groups을 선택하고 탐색할 수 있습니다. group을 선택하는 것은 group에 포함된 모든 items를 선택하는 것과 같습니다. (46607897)
* Interface Builder에는 device 및 layout을 변경할 수 있는 popovers와 재설계된 canvas bottom bar가 있으며 device appearance과 orientation을 변경할 수 있도록 토글합니다. (68288315)
* `UIButton` 및 `UIBarButtonItem`의 `changesSelectionAsPrimaryAction` 속성에 대한 지원이 추가되었습니다. 메뉴를 설정하고 `showMenuAsPrimaryAction`을 활성화하여 Pop-Up button을 만듭니다. (69890483)
* object library에서 iOS Core Location Buttons authoring 및 dragging를 지원합니다. Core Location button을 누르면 device의 current location에 대한 일회성 권한이 부여됩니다. project는 `CLLocationButton`을 사용하기 위해 CoreLocationUI framework를 연결해야 합니다. (70781230)
* iOS storyboards 및 xib에서 binary nibs를 컴파일할 때 재현성이 개선되었습니다. (71004831)
* static table views의 table view cells에 사용할 new content configuration styles에 대한 지원이 추가되었습니다. (71258693)
* UITabBar 및 UIToolbar inspectors는 이제 `scrollEdgeAppearance` 구성을 지원합니다. (71788169)
* Interface Builder는 이제 `UIButton.menu`를 지원합니다. (72059569)
* launch storyboards를 편집할 때 Xcode는 total image resource size가 runtime threshold limits을 초과하면 design time warning를 표시합니다. (72349945)
* 이제 Watch Storyboards의 preview에 photorealistic bezels 대신 canvas style bezels이 표시됩니다. (73070504)
* 이제 Interface Builder scenes에서 다음 accessibility 설정을 미리 볼 수 있습니다. Dynamic Type, Bold Text, Button Shapes, On/Off Labels, Increase Contrast, and Reduce Transparency. canvas button bar에서 accessibility button을 클릭하고 accessibility popover에서 설정을 지정하여 이러한 설정을 활성화할 수 있습니다. (73208721)
* 이제 `UILabel`의 `showsExpansionTextWhenTruncated` property를 활성화하여 label이 잘릴 때 tool tip 확장을 표시할 수 있습니다. (73581591)
* Document Inspector > Simulated Metrics > Scene Sizes에서 Mac Catalyst simulated scene sizes를 Customize합니다. (73587968)
* Mac Catalyst로 빌드된 앱의 attributes inspector를 통해 `UIControl` object에 대한 tooltips을 지정합니다. (73594175)
* Interface Builder는 이제 `UIBarButtonItem.menu`를 지원합니다. 이것을 `UIBarButtonItem.changesSelectionAsPrimaryAction` property를 함께 사용하여 pop-up button을 만듭니다. (73671137)
* Interface Builder는 이제 `shippingTrackingNumber`, `flightNumber` 및 `dateTime`을 포함한 새로운 `UITextContentType` properties를 지원합니다. (73769660)
* iOS, iPadOS, macOS 및 tvOS scenes은 hierarchical 및 palette라는 두 가지 새로운 SF Symbol를 지원합니다. (73774179)
* When you select an SF Symbol, you can select either of the following modes from the render mode drop-down:
  * hierarchical mode를 사용하여 symbol’s primary layer color를 customize합니다. 다른 layer는 primary color의 감소된 알파 혼합 버전으로 그립니다.
  * palette mode를 사용하여 각 개별 layer의 color를 지정합니다.
* Interface Builder는 이제 `Plain`, `Gray`, `Tinted` 및 `Filled`를 포함한 `UIButtonConfiguration` style 버튼 제작을 지원합니다. (73789335)
* UINavigationBar, UITabBar 및 UIToolbar inspectors는 이제 UIBarAppearance instance configuring을 지원합니다. (74054594)
* UIButton과 UISlider는 Mac Catalyst로 빌드된 앱에서 선호하는 동작 스타일을 선택할 수 있도록 지원합니다. (74260900)
* view controller의 size inspector에서 Freeform simulated metrics을 사용하는 Storyboard scenes은 이제 resize knobs를 사용하여 canvas에서 직접 크기를 조정할 수 있습니다. (74298762)
* NSButton Bevel type은 macOS 12에서 Bevel Color 지원합니다. (74537793)
* macOS 12용 앱에서 attributes inspector의 localize property를 사용하여 non-system `NSMenuItem`에 대해 localized key에 해당하는 옵션을 구성할 수 있습니다. (76168930)
* iOS 15용 앱에서 attributes inspector의 localize property를 사용하여 non-system UI menu command에 대해 localized key에 해당하는 옵션을 구성할 수 있습니다. (76622527)

### Resolved Issues
* UIView 계층 관련 involved uninstalled constraints을 포함하는 canvas 렌더링 및 storyboard 컴파일 문제가 수정되었습니다. (23319744) (FB5697880)
* multi-platform targets에 대한 @IBDesignable view 지원이 수정되었습니다. (65449051) (FB7964472)
* iPad canvas safe areas에서 status bar inset을 허용하는문제를 수정했습니다. (67828638)
* outline view에서 항목을 이동하면 항목이 잘못 재정렬될 수 있는 문제가 수정되었습니다. (69307918) (FB8724081)
* `Date Formatter‘s Advanced Edit Mode` inspector table이 `Dark Mode`를 제대로 지원하지 않는 문제를 수정했습니다. (70051451) (FB8782722)
* Apple 실리콘이 탑재된 Mac의 Designables에 대한 렌더링 문제를 수정했습니다. (71782893) (FB8921448)
* outline pane width 및 visibility과 관련 state restoration를 수정했습니다. (72184267)
* Apple 실리콘을 사용하는 Mac에서 활성화된 Rosetta와의 Interface Builder 및 Asset Catalog 호환성 문제를 수정했습니다. (74180445) (FB8999052)
* Interface Builder inspector’s의 로딩 성능을 개선했습니다. (76425091)
* 이제 UIButton system configuration styles에 font property inspector를 사용할 수 있습니다. (76573915)
* inspector의 Optional number properties에는 더 이상 clear values checkboxes가 없습니다. 대신 value를 선택하고 delete key를 눌러 값을 지울 수 있습니다. (77109701)
* macOS 10.15 및 이전 버전에서 실행되는 nibs에서 [<i class="fas fa-link"></i>  MKMapView](https://developer.apple.com/documentation/mapkit/mkmapview){:target="_blank"}를 사용할 때 발생하는 runtime crash issue를 수정했습니다. (78522530)
* Xcode는 document unarchiving을 하는 동안 더 이상 `NScollectionViewGridLayout.maximumNumberOfRow` 및 `NScollectionViewGridLayout.maximumNumberOfColumns`를 0으로 reset하지 않습니다. (80157777) (FB9262860)

## Linking
### New Features
* `dyld` shared cache가 여러 파일로 분할되었습니다. 새 구조를 사용하도록 tools that inspect the cache를 업데이트하십시오. (36378398)
* 이제 macOS 12 또는 iOS 15 이상의 deployment target으로 구축된 모든 프로그램과 `dylibs`는 chained fixups format을 사용합니다. 이렇게 하면 서로 다른 load commands와 `LINKEDIT` data가 사용되며 이전 OS 버전에서는 실행되거나 로드되지 않습니다. (49851380)
* `dyld2`와 `dyld3`이 통합되었습니다. 이제 모든 플랫폼에 하나의 `dyld`만 있습니다. (69400751)
* DriverKit runtime에는 이제 `dyld` shared cache가 있습니다. (70706923)
* `DYLD_PRINT_SEARCHING` environment variable이 launch time에 1로 set된 경우, `dyld`는 로드할 `dylib`을 찾기 위해 검색한 모든 위치에 대한 경로를 print합니다. (76430687)

### Resolved Issues
* `dyld` shared cache에서 `__DATA_CONST` 영역을 editing할 수 있는 문제를 수정했습니다. 이제 read-only입니다. (22175031)
* iOS에서 `-pagezero_size` 비호환성 해결. iOS는 이제 `-pagezero_size`를 무시합니다. (69436371) (FB8733025)
* `-image_base` 옵션이 필수로 필요한 문제를 해결했습니다. `PIE`를 대상으로 할 때 `ld64`는 이제 `-image_base`를 무시합니다. (72143464)

### Deprecations
* `-whatsloaded` 옵션은 더 이상 지원되지 않습니다. (73366865) (FB8975608)

## Localization
### New Features
* Xcode는 이제 strings, 기타 localized assets의 번역을 보고 편집하기 위해 Xcode Localization Catalogs(.xcloc)를 열 수 있습니다. 이 기능의 일부로 `.xcloc`은 이제 Finder에서 package file-type입니다. localization catalog의 내용을 검사하려면 Finder에서 Show Package Contents를 사용하십시오. (30024017)
* Swift String을 추출하는 새로운 Compiler 사용 설정은 `Text()`, `String(localized:)`, `AttributedString(localized:)` initializers 에서 string interpolations 및 string literals을 정확하게 추출하기 위해 Swift compiler를 호출 합니다. SwiftUI’s `LocalizedStringKey`, Foundation의 `StringLocalizationKey`입니다. 이 설정을 활성화하면 localization을 위해 내보내고 가져올 때 프로젝트의 모든 localized targets이 컴파일됩니다. 이 build setting은 모든 새 프로젝트에서 기본적으로 활성화되지만 기존 Swift projects에서는 선택할 수 있습니다. (58023398)
* Objective-C 코드에서 새로운 `NSLocalizedAttributedString` macro를 사용하는 strings 추출을 위한 `genstrings`, localization import 및 export에 대한 지원이 추가되었습니다. (73067097)
* multiple localizations의 Errors는 이제 localization exporting 시 single alert dialog에 집계됩니다. (73562452)
* Xcode는 localization exporting 시 `Info.plist` 파일에서 `NSGKFriendListUsageDescription`, `NSLocationTemporaryUsageDescriptionDictionary` 및 `NSFallDetectionUsageDescription`을 자동으로 추출합니다. (75813015)

### Resolved Issues
* 하나의 localization에서 새로 추가된 localization으로 content를 불필요하게 복사해야 하는 문제를 수정했습니다. 새 localization를 추가할 때 development language content가 존재하지 않는 경우 더 이상 references language에서 content를 복사할 필요가 없습니다. (46222774) (FB5671738)
* `genstrings`가 `Text()` 대신 SwiftUI 코드에서 모든 `Text*()` string literals을 추출하는 문제를 수정했습니다. (67694778) (FB8524688)
* XML character escape sequences가 ​​있는 `XLIFF`의 localized strings을 가져오지 못하는 문제가 수정되었습니다. (68924128) (FB8695129)
* workspace의 multiple projects에 동일한 파일에 대한 references가 있는 경우 Xcode가 프로젝트에서 콘텐츠를 비결정적으로 내보내는 문제가 수정되었습니다. (71859474)
* `.lproj` directory 내의 directory에 localizations 파일이 존재하는 localized files을 가져올 때 Xcode가 충돌하는 문제를 수정했습니다. (72755034) (FB8958080)

### Deprecations
* Localized String SwiftUI 지원 build setting은 새로운 Swift compiler-based string extraction을 위해 더 이상 사용되지 않습니다. (80817452)

## Metal
### New Features
* Metal Debugger는 이제 선택적 Shader Debugging을 지원하므로 대규모 Compute shaders의 debugging scope를 제한할 수 있습니다. 이렇게하면 shader-debugger session 생성 및 iteration times이 훨씬 빨라집니다. (67747242)
* Metal Debugger의 새로운 Capture Controls을 사용하면 Metal workload의 어느 부분을 정확하게 캡처할지 결정할 수 있을 뿐만 아니라 multiple frames 또는 scopes를 capture할 수 있는 옵션을 선택할 수 있습니다. (68219613)
* Metal Debugger는 이제 `metallibsym` 파일 가져오기를 지원하므로 `metallib`에 shader sources를 포함하지 않고도 앱에서 Metal shader debugging 및 profiling을 수행할 수 있습니다. (68942327)
* 이제 Metal Debugger에서 Apple GPU에 대한 GPU Timeline을 사용할 수 있습니다. 이 timeline을 사용하여 큐레이션된 GPU Counters set와 함께 Metal GPU commands의 parallel execution을 visualize하고 검사하십시오. timeline을 통해 앱의 성능 분석에 대한 추가적인 insight과 control over을 얻을 수 있습니다. (69178472)
* Metal Pipeline State Objects는 이제 Metal Debugger의 Memory Viewer에서 Metal Pipeline States 및 Metal Libraries를 위한 새로운 viewer, Metal Pipeline States를 설명하는 GPU Memory를 포함하여 Metal Debugger에서 resources로 표현됩니다. (69377133)
* 새로운 Consistent GPU Performance State profiling workflows는 이제 Instruments의 Metal System Trace, Xcode의 Metal Debugger 및 새로운 Condition Inducer에서 사용할 수 있습니다. Consistent GPU Performance State profiling을 통해 device를 consistent GPU performance state로 설정할 수 있으므로 일관성있고 안정적인 방법으로 앱의 performance analysis을 수행할 수 있습니다. (69404088)
* 이제 Metal System Trace template의 recording 옵션에서 GPU performance state를 override할 수 있습니다. Instruments는 또한 iOS devices에서 recording 시 새로운 GPU Performance State track을 추가합니다. (69523159)
* Metal Debugger는 이제 새로운 고급 Acceleration Structure Viewer와 함께 Metal ray tracing을 지원합니다. (70112081)
* 이제 Metal Application recording settings이 profiled되는 device에만 적용됩니다. (74116877)

### Resolved Issues
* Metal Shader Validation이 다음과 같은 새로운 Metal API를 지원하도록 확장되었습니다: Indirect Command Buffers, Dynamic Libraries, Function Pointers, Visible Function Tables, and Pull Model Interpolation. (78491579)

### Deprecations
* TextureTool은 deprecated 되었습니다. 대신 새로운 TextureConverter tool을 사용하도록 texture compression workflow를 전환하십시오. TextureConverter는 전체 범위의 texture compression formats을 제공하며 compression pipeline을 보다 효과적으로 제어할 수 있습니다. (73370277)

## Organizer
### New Features
* 이제 Xcode는 데이터 보존 시간이 길어졌으며, 거의 real time으로 crash reports를 제공합니다. Xcode는 영향을 받는 unique devices로 정렬된 목록에서 crash signature("충돌 지점")별로 crash logs를 집계합니다. 지난 1년~현재까지의 Aggregated Crash Point data를 사용할 수 있습니다. any list filter selection을 선택할 경우 Crashes Organizer에는 최대 1,000개의 Crash Points이 표시됩니다. Additionally, 또한 new View > Reload Organizer 메뉴 항목은 Organizer의 content를 다시 로드합니다. (54901702)
* Xcode는 이제 더 많은 filtering 기능과 더 많은 통계를 포함한 crash reports를 제공합니다. 기간(지난 날, 지난 2주, 작년), 모든 버전 또는 특정 기록 app version, 모든 build 또는 특정 기록 app build, 제품 유형과 같은 필터 기준으로 top Crash Points의 순위 목록을 쿼리할 수 있습니다. App Clip, app extension, App Store 또는 TestFlight에서 release 된 설치 가능한 watchOS app 또는 main app, iOS, macOS 또는 watchOS. 다음 세 가지 새로운 관점으로 crash 통계를 볼 수 있습니다. 기간(Last Day, Last Year), app version 및 release history. graph area의 time series data는 last 24 hours, by-month, last year의 영향을 받은 unique devices를 보여줍니다. 또한 Xcode crash reporting은 이제 macOS용 TestFlight에 배포된 앱을 지원합니다. (78882594)
* 이제 URL로 crash reports를 공유할 수 있습니다. 새로운 버튼으로 Crash Point URL을 공유할 수 있습니다. Crash Point URL을 클릭하면 앱에 액세스할 수 있는 모든 개발자가 Organizer에서 Crash Point를 볼 수 있습니다. (78882655)
* 이제 Xcode는 crashing issues에 대한 TestFlight Feedback을 표시하여 무엇이 잘못되었는지 더 잘 파악할 수 있도록 합니다. TestFlight Crash Feedback 은 이제 선택한 모든 Crash Point에 대한 새로운 TestFlight Feedback Inspector에서 볼 수 있습니다. Safari에서 TestFlight 충돌 피드백을 볼 때 새로운 "Open in Xcode"를 통해 Xcode Organizer에서 Crash Point를 열 수 있습니다. (78882718)
* 이제 특정 기록 앱 버전, 특정 기록 앱 빌드, App Clip, app extension 또는 main app과 같은 제품 유형, TestFlight 또는 App Store의 release history을 기반으로 Energy reports 목록을 필터링할 수 있습니다. (78882776)
* Xcode Organizer의 새로운 Scroll Hitch Goals를 사용하면 앱 버전의 스크롤 경험을 쉽게 분석할 수 있습니다. chart의 bars는 해당하는 목표 수준에 따라 red, yellow 또는 green으로 표시됩니다. 각 color는 chart 오른쪽의 key와 연결됩니다; 키는 각 goal level의 임계값에 대한 자세한 정보를 제공합니다. (62735038)
* 앱에 대한 metrics을 볼 때 이제 앱의 App Clip에 대한 metrics을 볼 수 있는 옵션이 제공됩니다. App Clip metrics data를 보려면 App Clip filtering option을 선택합니다. (63915380)
* Xcode Organizer의 새로운 Terminations metric는 foreground 및 background terminations를 각 사유별 구분하여 보여줍니다. 이 organization은 특정 앱의 가장 일반적인 termination 원인에 대한 세부 정보를 제공합니다. (64376250)
* Xcode Organizer의 기록 데이터는 이제 각 metric chart에 대해 최대 16개의 app의 latest versions을 표시하여 더 광범위한 앱의 성능 추세를 제공합니다. (64382966)
* 이제 metric항목을 볼 때 inspector에 앱의 release date 정보가 표시됩니다. (64995828)
* Xcode Organizer의 Disk Write Reports에 대한 Qualitative Insights은 Insights in the inspector에서 Insights이라는 새로운 정보를 보여줍니다. 이러한 insights에는 앱의 Disk Writes를 줄이는 데 도움이 되는 optimizations이 포함됩니다. (66926840)
* 이제 Xcode Organizer에서 Smart Insights를 사용하여 이전보다 더 빠른 앱의 성능, 성능 회귀를 발견할 수 있습니다. 자세한 내용은 [<i class="fas fa-link"></i> Analyzing the Performance of Your Shipping App](https://developer.apple.com/documentation/Xcode/analyzing-the-performance-of-your-shipping-app#Read-Data-for-Smart-Insights){:target="_blank"}을 참조하십시오. (71420981)

## Playgrounds
### Known Issues
* macOS를 대상으로 하는 Xcode Playground에서 TabularData framework를 Importing하면 symbols가 누락될 수 있습니다. (77162151)

  해결 방법: 가능한 경우 Playground의 platform을 iOS로 설정합니다.
* Xcode Playgrounds는 Swift Concurrency language 구성을 지원하지 않습니다. (79408099)

## Previews
### New Features
* 이제 Previews에서 view를 previewing 하는 동안 view들의 accessibility elements 검사를 지원합니다. 이 지원에는 macOS 12가 필요합니다. (78297929)

### Deprecations
* Xcode 13은 더 이상 preview debugging을 위한 Previews canvas에 menu item을 포함하지 않습니다. 대신 Debug > Attach to Process menu item 항목을 사용하여 previewed app에 debugger를 연결합니다. (73981969)

## Project Navigator
### New Features
* project navigator는 default location에 있을 때 Products group을 숨깁니다. Product > Show Build Folder 메뉴 항목이 가장 일반적인 사용을 대체합니다. (71561549)
* 이제 Move Focus to Editor command을 통해 vim 방향 이동 키를 해석합니다. (71754671) (FB8918700)
* scheme editing sheet의 maximum size가 더 이상 없습니다. (73158957) (FB8969432)

### Resolved Issues
* `Command-F`를 사용하여 build log를 검색하면 Xcode가 crash issue가 수정되었습니다. (52943982)
* 기본적으로 project navigator는 파일 확장자와 document tab titles을 숨깁니다. Xcode의 general preferences에서 이 동작을 구성하십시오. (71203294)
* run destination menu에서 무선 devices의 들여쓰기를 수정했습니다. (72926304) (FB8964983)
* Xcode에서 큰 폴더를 이동하는 것이 더 빠릅니다. (77217929)

## Sanitizers
### Resolved Issues
* Undefined Behavior Sanitizer는 bit width가`int`보다 작은 형식의 증감 전/후를 처리할 수 있습니다. (60943408)
* Address Sanitizer가 활성화된 상태에서 실행하는 동안 memory allocation이 실패할 수 있는 Apple 실리콘에 설치된 있는 Mac의 문제를 수정했습니다. (75302812)
* Thread Sanitizer로 인해 프로그램이 crash되거나 잘못된 report를 보고하는 macOS 12의 문제가 해결되었습니다. (78319076)

## Signing and Distribution
### New Features
* `xcodebuild`는 이제 Apple Developer websited에서 인증을 위해 App Store Connect API keys 사용을 지원합니다. 이를 통해 build machines 및 continuous integration setup과 같은 headless environments에서 `xcodebuild`를 통한 automatic signing을 사용할 수 있습니다. `xcodebuild`에서 API 키를 사용하려면 [<i class="fas fa-link"></i> App Store Connect](https://appstoreconnect.apple.com/access/api){:target="_blank"}에서 API key를 생성하고 새로운 parameters인 `authenticationKeyPath`, `authenticationKeyID` 및 `authenticationKeyIssuerID`를 각각 사용하여 해당 identifier 및 team’s issuer identifier와 함께 key를 `xcodebuild`에 전달합니다. 키를 생성할 때 역할을 할당하여 자동 서명 작업을 수행하기 위한 권한을 제어할 수 있습니다. 키를 생성할 때 role을 할당하여 automatic signing tasks을 수행하기 위한 permissions을 제어할 수 있습니다. 키 생성 및 관리에 대한 자세한 내용은 [<i class="fas fa-link"></i> Creating API Keys for App Store Connect API](https://developer.apple.com/documentation/appstoreconnectapi/creating_api_keys_for_app_store_connect_api){:target="_blank"}를 참조하십시오. (51444716)
* 이제 Xcode는 새 앱을 App Store Connect에 처음 업로드할 때 app record를 생성하도록 제안합니다. 앱 레코드를 생성하기 전에 Xcode의 distribution assistant내에서 App의 name, primary langua 및 `SKU`를 직접 구성할 수 있습니다. (57572562) (FB7476283)
* App Store Connect에 앱을 업로드할 때 Xcode의 distribution assistant는 앱에 유효한 빌드 번호(CFBundleVersion)가 있는지 감지합니다. 앱에 잘못된 번호(예: 이전에 사용되었거나 현재 빌드 번호보다 앞선 번호)가 있는 경우 distribution assistant는 자동으로 번호를 유효한 번호로 증가시키는 옵션을 제공합니다. 또한 distribution assistant는 앱에 포함된 모든 콘텐츠(예: such as app extensions, App Clips, or watchOS apps)의 빌드 번호가 앱과 동기화되도록 합니다. 이것은 source code나 archive를 수정하지 않습니다; Xcode는 앱을 packaging하고 App Store Connect에 업로드하기 전에 앱의 staged copy에서 빌드 번호를 업데이트합니다. (59826409)
* 이제 Xcode distribution assistant의 Automatic signing이 cloud signing을 지원합니다. cloud signing을 사용하면 Xcode distribution signs는 Apple servers에서 생성 및 관리되는 signing certificates를 사용하여 앱에 signing하므로 Apple ID로 Xcode에 로그인하는 것 외에 local Mac에서 설정할 필요가 없습니다. Cloud signing은 App Store Connect, Ad Hoc, Enterprise 또는 Developer ID distribution에 signing할 때 사용할 수 있습니다. Cloud signing certificates는 Apple 서버에 안전하게 저장됩니다. Mac에서 private key를 전송하거나 저장할 수 없습니다. standard distribution signing certificates와 마찬가지로 cloud signing certificates는 Admin role(또는 Account Holder for Developer ID)이 있는 개발 팀 members만 액세스할 수 있습니다. App Store Connect(Users and Access)를 사용하여 다른 roles을 가진 users에 대한 permissions을 설정합니다. cloud signing certificates를 저장하거나 팀의 다른 개발자와 공유할 필요가 없습니다. 필요한 permissions이 있는 모든 팀원이 cloud signing을 통해 distribution으로 signing할 수 있기 때문입니다. Mac에 유효한 distribution signing certificate와 일치하는 provisioning profile이 이미 설치되어 있는 경우 cloud signing을 사용하지 않고 로컬로 signing합니다. 또한 manual distribution signing을 사용할 때는 cloud signing을 사용할 수 없습니다. (70706409)
* Xcode 13은 Mac에서 TestFlight용 apps provisioning을 지원합니다. macOS 앱이 TestFlight에 적용되려면 provisioning profiles가 포함되어야 합니다. Mac 앱을 App Store Connect에 업로드하고 distribution assistant에서 automatic signing을 사용하면 assistant가 앱에 provisioning profiles를 자동으로 포함합니다. manual distribution signing을 사용하는 경우 Apple Developer website에서 provisioning profiles을 만든 다음 distribution assistant의 manual distribution signing section을 선택합니다. (72824383)
* 이제 command line에서 `notarytool`을 사용하여 Apple notary service와 상호 작용할 수 있습니다. 전체 설명은 `man notarytool`이 있는 매뉴얼 페이지를 참조하거나 `xcrun notarytool --help`로 사용 가능한 명령을 확인하십시오. custom notarization workflows에 대한 자세한 내용은 [<i class="fas fa-link"></i> Customizing the Notarization Workflow](https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution/customizing_the_notarization_workflow){:target="_blank"}을 참조하십시오. (78516542)

### Resolved Issues
* 계정에 Developer role인 경우 automatic signing이 Cloud Containers, App Groups, or Apple Pay Merchant Identifiers를 사용하는 앱의 provisioning profiles을 복구할 수 없는 문제를 해결했습니다. (30185440) (FB5641770)
* Xcode가 smart card를 사용하여 codesign에 실패하는 문제를 해결했습니다. (58266781) (FB7516556)
* bitcode로 만들어진 universal Mac Catalyst framework 인 경우 Xcode가 sign하지 못하는 문제를 수정했습니다. (71599193)

### Known Issues
* 큰 `.zip` 파일과 함께 `notarytool` submit을 실행하면 `notarytool`이 영구적으로 중단될 수 있습니다. (78513932)

  해결 방법: 앱을 `.pkg` 또는 `.dmg`로 제출하거나 여러 개의 작은 `.zip` 파일을 제출하거나 `altool`을 사용합니다.
* cloud certificate서 type을 사용할 수 있는 permission이 없는 경우 해당 certificate로 signing할 수 없으며 certificate type을 알고 있더라도 "<VALID_CERT_TYPE>_Managed is unknown" 오류가 표시됩니다. (78538221)
* Xcode는 App Store Connect가 업로드 후 빌드 reject 시 distribution workflow 중에 build number를 잘못 재사용하려고 할 수 있습니다. (78838509)

  해결 방법: 다시 빌드하기 전에 앱의 build number를 수동으로 늘리십시오.
* macOS 11의 Organizer에서 local signing을 사용하여 내보낼 때 Xcode가 watchOS 앱에 올바르게 다시 re-sign하지 않습니다. (82944652)

  해결 방법: cloud signing을 사용하여 앱을 내보내거나 macOS 12에서 내보냅니다.

## Simulator
### Known Issues
* Shazam Catalog 인식은 simulated devices에서 작동하지 않습니다. (77564423)

  해결 방법: physical device를 사용합니다.
* music requests이 있는 content 로드와 같은 [<i class="fas fa-link"></i> MusicKit](https://developer.apple.com/documentation/MusicKit) 기능은 simulated devices에서 작동하지 않습니다. (78559381)

  해결 방법: physical device에서 앱의 MusicKit 기능을 테스트합니다.
* Simulated iPhone mini devices는 부분적인 화면 업데이트를 잘못 렌더링하여 visual 결함을 일으킬 수 있습니다. (82423740) (FB9569039)

  해결 방법: 미니가 아닌 simulated device를 사용합니다.
* simulated watchOS devices의 Always On 모드에서 콘텐츠가 업데이트되면 일부 콘텐츠가 사라지거나 시각적 artifacts가 나타날 수 있습니다. (82732227)

  해결 방법: device에서 테스트하여 Always On 동작을 확인합니다.

## Source Control
### New Features
* 이제 GitHub 또는 Bitbucket Server 계정에 로그인하면 Xcode’s source control을 사용하여 create, review, and merge pull requests를 할 수 있습니다. (62934369)

* 이제 document tab bar의 모든 editor(또는 editor split)에서 code review를 활성화할 수 있으며 기본적으로 inline presentation에서 비교를 표시합니다. editor 하단에 있는 New commit selectors를 사용하면 표시되는 diff를 customize할 수 있습니다. (68880112)

### Resolved Issues
* 이전에 신뢰할 수 있었던 fingerprint가 변경된 경우 Xcode는 Source Control operations에 대한 SSH fingerprint를 확인합니다. (66421452) (FB8234008)

### Known Issues
* Xcode의 pull request feature는 forked repositories에서 작동하지 않습니다. upstream repository에 pull requests를 제출할 수 없습니다. (60009682)

  해결 방법: 대신 single repository 내의 branches에 pull requests을 제출하십시오.

* pull request’s activity view에 comment를 추가할 때, layout은 때때로 눈에 띄게 re-draws하기 때문에 뷰가 점프하게 됩니다. (75595247)

* activity view에서 pull request를 삭제해도 삭제 내용 표시가 로컬에 업데이트되지 않을 수 있습니다. 그러나 삭제는 서버에서 수행됩니다. (76704508)

  해결 방법: pull request view를 Close합니다. source control 공급자의 웹 인터페이스에서 pull request 삭제를 확인할 수도 있습니다.

* diff 외부의 라인에 대한 pull request comments을 생성하면 오류가 발생합니다. (78275800)

* Xcode는 GitHub에서 호스팅되는 pull request를 "decline"하는 옵션을 제공할 수 있습니다. 이 작업은 지정된 repository에서 수행을 할 수 없거나 허용되지 않을 수 있습니다. (78475833)

  해결 방법: pull request을 declining하는 대신 GitHub website를 사용하여 pull request을 close하십시오.

* PR code comments은 때때로 PR Activity View에서 잘릴 수 있습니다. (78484455)

* repository에 여러 개의 remotes가 구성된 경우 pull request의 target branch selector가 사용 가능한 branches로 채워지지 않을 수 있습니다. (78491019)

  해결 방법: origin이 아닌 remotes을 제거합니다.

* Xcode에서 PR에 commits을 추가하면 Xcode를 re-launch할 때까지 Changes navigator가 업데이트되지 않습니다. (81229110)

  해결 방법: Xcode를 다시 실행합니다.

* Git repository로 new project를 생성하면 repo를 initialize하지 못하는 경우가 있습니다. (81874148)

  해결 방법: project folder의 root level에서 숨겨진 .git 폴더를 제거하고 Xcode의 Source Control preferences 설정 탭에서 author name과 email address를 추가하고 Xcode의 Source Control 메뉴에서 새 Git repository를 만듭니다.

* PR view에 있는 동안 active 및 published PR이 있는 project를 닫은 다음 project를 빠르게 다시 열면 Xcode에서 error dialog를 display할 수 있습니다. (82401004)

## Source Editor
### New Features
* Xcode 13은 Vim key bindings을 도입하여 기존 editor 기능과 결합된 source editor의 vim 환경을 emulating합니다. (3716281)

  `Text Editing > Editing`에서 Vim key bindings Enable option을 사용하여 Preferences에서 Vim 키 바인딩을 활성화합니다.

* `Edit > Copy Location`를 선택하여 "<filename>:<line-number>" 형식으로 선택 항목의 current location를 Clipboard에 복사할 수 있습니다. (10505001) (FB5931643)

* Swift에서 placeholder를 closure로 확장할 때 code completion은 `<#Type#>` 대신 closure의 argument names을 사용합니다. (53180195)

* Xcode 13의 Swift syntax highlighting 표시는 파일을 편집하고 탐색하는 동안 즉각적이고 깜박임이 없습니다. (54536855)

* 이제 Swift Jump to Definition은 코드가 불완전하거나 프로젝트를 컴파일할 수 없는 경우에도 보다 탄력적인 경험을 제공합니다.

  Swift class, protocol 또는 method 선언에서 Jump to Definition는 전체 workspace에서 모든 subclasses, extensions 및 protocol 준수 유형에 대한 쉬운 탐색을 제공합니다. (54536865)

* Xcode 13에는 특히 project source code에 구조적 및 논리적 불일치가 있는 경우 안정성과 성능을 극대화하는 재설계된 Swift code completion 기능이 포함되어 있습니다. Xcode 13의 코드 완성 기능은 주변 소스가 손상된 경우에도 빠르게 생각을 마무리할 수 있도록 도와줍니다. Completions은 더 빨리 나타나고 더 예측 가능하므로 입력을 줄인 후에 completions될 가능성이 가장 높습니다. (54536896)

  types과 methods를 완성하는 것 외에도 Xcode 13의 code completion은 `for item in items {`, 또는 `guard let item = item else { return nil }`과 같은 `switch` 문과 `enum case`가 수반되는 전체 `switch` 문을 제공합니다. 또한 Code completion은 또한 properties 전체를 검색하여 view에서 `cornerRadius`를 완료할 때 `layer.cornerRadius`와 같은 chained completions을 제공합니다.

  Code completion은 아직 정확하지 않은 표현식을 완성하는 데 도움이 됩니다. import 되지 않은 modules의 유형을 찾아 식별하고 필요한 import를 자동으로 추가합니다. 주변 소스에 오류가 있어도 code completion은 여전히 ​​당신이 의미하는 바를 유추합니다. 유효하게 만드는 방법을 설명하는 message를 제공하는 동시에 원하는 completion을 제안합니다.

### Resolved Issues
* `MARKs`, `TODOs` 및 `FIXMEs`가 포함된 comments의 URLs를 클릭할 수 없는 문제가 수정되었습니다. (10488785)

* Objective-C에서 array 및 dictionary literals의 elements가 너무 오른쪽으로 들여쓰여 있는 문제가 수정되었습니다. (15964664)

* string literal이 end of a line가 아닐 때 auto-close 되지 않는 문제를 수정했습니다. (34433455) (FB5931169)

* documentation comment을 시작하기 위해 "///"를 입력하면 잘못된 font로 그려지는 문제가 수정되었습니다. (53331667)

* 기본 argument 또는 가변 argument 이후 argument labels에 대한 Swift code completion 기능이 향상되었습니다. (60346573)

* generic initializers의 argument labels에 대한 Swift code completion이 향상되었습니다. (64168588)

* multiline string literal 내의 newline이 literal의 들여쓰기를 따르지 않는 문제를 수정했습니다. (68076453)

* find bar을 표시할 때 line number가 동기화되지 않은 상태로 그려지는 문제가 수정되었습니다. (70554325)

* Vim Mode에 대한 액세스를 개선하기 위해 Xcode는 Enable Vim key bindings 설정을 preference `Edit > Vim Mode` 메뉴 항목으로 대체했습니다. (75491567)

* Xcode는 이제 editor별로 line wrapping preference 설정 변경을 지원합니다. (79168822, 79428189) (FB9157365)

## Static Analyzer
### New Features
* static analyzer는 이제 side effects, infinite loops 및 더 많은 `C++11 std::move` 오용 사례에 대해 경고합니다. (34520956)

## StoreKit
### New Features
* Xcode의 StoreKit Testing은 StoreKit의 새로운 최신 Swift 기반 API를 사용하여 구축된 인앱 구매에 대한 포괄적인 테스트를 지원합니다. StoreKit 2에 대한 자세한 내용은 [<i class="fas fa-link"></i> StoreKit](https://developer.apple.com/documentation/storekit){:target="_blank"}을 참조하십시오. (69846798)

## Swift
### New Features
* Swift now natively supports concurrency programming using async/await and actors. For more information, see What’s new in Swift, Meet async/await in Swift, and Explore structured concurrency in Swift. (SE-0296, SE-0306, 21398040, 78028712, 78029422)

* Functions and properties that should only be accessed from the main thread can be placed on the main actor by annotating them with the @MainActor attribute. When calling a main-actor function, the call must come from a context that is itself on the main actor, or the call must be asynchronous. (70101562)

  For example:
  ```swift
  @MainActor func f() { }

  @MainActor func g() {
    f() // Already on the main actor. OK to call.
  }

  func h() async {
    f()            // Error: You can't synchronously call f(), because h() isn't on the main actor.
    await f()  // OK: Swift executes the asynchronous call to f() on the main actor.
  }
  ```
  Types can be placed on the main actor, which implies that all of their members are also on the main actor:
  ```swift
  @MainActor class MyViewController: UIViewController {
    func method() { } // This method is implicitly on @MainActor.

  }
  ```
* Asynchronous functions can create concurrently executing child tasks with async let bindings. The child task begins at the point that the parent declares the async let, and the variables the async let declares await at the point where they’re used. The async let waits until the child task completes and returns a value. (70101851)

  For example:
  ```swift
  func chopVegetables() async throws -> [Vegetables]
  func marinateMeat() async -> Meat
  func preheatOven(temperature: Int) async -> Oven

  func makeDinner() async throws -> Meal {
    async let veggies = chopVegetables()
    async let meat = marinateMeat()
    async let oven = preheatOven(temperature: 350)
  
    let dish = Dish(ingredients: await [try veggies, meat])
    return try await oven.cook(dish, duration: .hours(3))
  }
  ```
  All child tasks complete before the scope in which they are declared exits.

* The “for” loop can be used to traverse asynchronous sequences in asynchronous code. (SE-0298, 78027927)
    ```swift
  for try await line in myFile.lines() {
    // Do something with each line
  }
  ```
  Asynchronous for loops use asynchronous sequences, defined by the protocol AsyncSequence and its corresponding AsyncIterator.

* Swift translates an Obj-C method that delivers its results asynchronously via a completion handler into an async method that directly returns the result (or throws). (78028295)

  For example, Swift translates the following Objective-C method from CloudKit:
  ```objectivec
  - (void)fetchShareParticipantWithUserRecordID:(CKRecordID *)userRecordID
    completionHandler:(void (^)(CKShareParticipant * _Nullable, NSError * _Nullable))completionHandler;
  ```
  <br/>
  into an async throws method that returns the participant instance:
  ```swift
  func fetchShareParticipant(
    withUserRecordID userRecordID: CKRecord.ID
  ) async throws -> CKShare.Participant
  ```
  <br/>
  Swift callers can invoke this async method within an await expression:
  ```swift
  guard let participant = try? await container.fetchShareParticipant(withUserRecordID: user) else {
    return nil
  }
  ```
* Read-only computed properties and subscripts can now define their get accessor to be async and throws, by writing one or both of those keywords between the get and {. (78029522)

  Thus, these members can now make asynchronous calls or throw errors in the process of producing a value:
  ```swift
  class BankAccount: FinancialAccount {
    var manager: AccountManager?
  
    var lastTransaction: Transaction {
      get async throws {
        guard manager != nil else { throw BankError.notInYourFavor }
        return await manager!.getLastTransaction()
      }
    }
  
    subscript(_ day: Date) -> [Transaction] {
      get async {
        return await manager?.getTransactions(onDay: day) ?? []
      }
    }
  }
  
  protocol FinancialAccount {
    associatedtype T
    var lastTransaction: T { get async throws }
    subscript(_ day: Date) -> [T] { get async }
  }
  ```

  Accessing these members, like lastTransaction above, requires appropriate marking with await or try:
  ```swift
  extension BankAccount {
    func meetsTransactionLimit(_ limit: Amount) async -> Bool {
      return try! await self.lastTransaction.amount < limit
      //                    ^~~~~~~~~~~~~~~~ this access is async & throws
    }
  }
  
  func hadWithdrawlOn(_ day: Date, from acct: BankAccount) async -> Bool {
    return await !acct[day].allSatisfy { $0.amount >= Amount.zero }
    //            ^~~~~~~~~ this access is async
  }
  ```
* #if ... #endif can now surround explicit member expression suffixes. (51690082)

  For example, the following code is now valid:
  ```swift
  VStack {
    TextField("email address", text: $emailAddress)
    #if os(iOS)
      .keyboardType(.emailAddress)
    #endif
      .disableAutocorrection(true)
  }
  ```
* Improved performance of overload resolution for generic operators, resulting in fewer “too complex to type check in reasonable time” errors in operator expressions. (65007946)

* You can now apply property wrappers to function and closure parameters. (SE-0293, 66866426, 78029226)

  For example:
  ```swift
  @propertyWrapper
  struct Wrapper<Value> {
    var wrappedValue: Value
  
    var projectedValue: Self { return self }
  
    init(wrappedValue: Value) { ... }
  
    init(projectedValue: Self) { ... }
  }
  
  func test(@Wrapper value: Int) {
    print(value)
    print($value)
    print(_value)
  }
  
  test(value: 10)
  
  let projection = Wrapper(wrappedValue: 10)
  test($value: projection)
  ```
  The call site can pass a wrapped value or a projected value, initializing the property wrapper using init(wrappedValue:) or init(projectedValue:), respectively.

* The Swift compiler’s incremental build mode now considers fine-grained dependency information embedded directly into imported Swift modules. This dramatically improves the rebuild time of large projects with many modules by reducing the number of files that rebuild, even across import boundaries. (69595010)

* Xcode has a new Optimize Object Lifetimes build setting, under Swift Compiler - Code Generation. Enabling this performs more aggressive ARC optimization and shortens object lifetimes, which can help reduce the memory your app uses. This option also helps you find bugs where code makes invalid assumptions about object lifetimes. (73894256, 76671692)

* The lazy keyword now works in local contexts. (78028578)

  For example, the following code is now valid:
  ```swift
  func test(useIt: Bool) {
    lazy var result = getPotentiallyExpensiveResult()
    if useIt {
      doIt(result)
    }
  }
  ```
* Whenever a reference to Self doesn’t impede the usage of a protocol as a value type, or a protocol member on a value of protocol type, the same is now true for references to [Self] and [Key : Self]. (78028842)

  For example:
  ```swift
  protocol Copyable {
    func copy() -> Self
    func copy(count: Int) -> [Self]
  }
  
  func test(c: Copyable) {
    let copy: Copyable = c.copy() // OK
    let copies: [Copyable] = c.copy(count: 5) // also OK
  }
  ```
* It is now possible to use leading-dot syntax in generic contexts to access static members of protocol extensions where Self is constrained to a fully concrete type. (78029041)

  For example:
  ```swift
  public protocol ToggleStyle { ... }
  
  public struct DefaultToggleStyle: ToggleStyle { ... }
  
  extension ToggleStyle where Self == DefaultToggleStyle {
    public static var `default`: Self { .init() }
  }
  
  struct Toggle {
    func applyToggle<T: ToggleStyle>(_ style: T) { ... }
  }
  
  Toggle(...).applyToggle(.default)
  ```
* Swift now considers default arguments of Optional type when deciding whether a call to a rethrows function can throw. (78029306)

  In Swift 5.4, such default arguments were ignored entirely by rethrows checking. As a result, the following example was accepted:
  ```swift
  func foo(_: (() throws -> ())? = nil) rethrows {}
  foo()  // No 'try' needed.
  ```
  <br/>
  However, the next example was accepted as well, even though the call to foo() can throw and the call site isn’t marked with try:
  ```swift
  func foo(_: (() throws -> ())? = { throw myError }) rethrows {}
  foo()  // 'try' *should* be required here.
  ```
  <br/>
  In the new behavior, the first example is accepted because the default argument is syntactically written as nil, which is known not to throw. The second example is correctly rejected because it’s missing a try, since the default argument can throw.

* Swift now supports Task local values. Using the @TaskLocal wrapper API, you can now bind and access values related to a running Task. The values are carried implicitly along with the Task’s execution and are inherited by child tasks. (SE-0311, 78269874)

* Swift has significantly restructured the Task API to account for changes to the design in SE-0304. (78269970)

* Declarations inside an actor that would normally be actor-isolated can explicitly become non-isolated using the nonisolated keyword. You can use declarations to conform to synchronous protocol requirements. (78331401)

  For example:
  ```swift
  actor Account: Hashable {
    let idNumber: Int
    var balance: Double
  
    nonisolated func hash(into hasher: inout Hasher) { // okay, non-isolated satisfies synchronous requirement
      hasher.combine(idNumber) // okay: can reference idNumber from outside the let
      hasher.combine(balance) // error: can't synchronously access actor-isolated property
    }
  }
  ```
* You can define a type as a global actor. Global actors extend the notion of actor isolation outside of a single actor type, so that global state (and the functions that access it) can benefit from actor isolation, even if the state and functions are scattered across many different types, functions, and modules. Global actors make it possible to safely work with global variables in a concurrent program, as well as modeling other global program constraints such as code that must only execute on the main thread or UI thread. A new global actor can be defined with the globalActor attribute. (79339591)

  For example:
  ```swift
  @globalActor
  struct DatabaseActor {
    actor ActorType { }
  
    static let shared: ActorType = ActorType()
  }
  ```
  You can use global actor types as custom attributes on various declarations, which ensures that those declarations are only accessed on the actor described by the global actor’s shared instance. For example:
  ```swift
  @DatabaseActor func queryDB(query: Query) throws -> QueryResult
  
  func runQuery(queryString: String) async throws -> QueryResult {
    let query = try Query(parsing: queryString)
    return try await queryDB(query: query) // 'await' because this implicitly hops to DatabaseActor.shared
  }
  ```
  <br/>
  The concurrency library defines one global actor, MainActor, which represents the main thread of execution. Use it for any code that must execute on the main thread, e.g., for updating UI.

### Resolved Issues
* Fixed an issue where capturing local property wrappers in a closure would result in a compiler error. (74457878)

* Converting a non-async function with an actor constraint into an async function without the actor constraint no longer produces an error. The async conversion introduces a hop to the necessary actor on the callee side. (76248452)

  For example, this code now compiles:
  ```swift
  @MainActor func onMainActor() -> Int { 5 }
  
  func test() {
    let _: () async -> Int = { @MainActor in
      onMainActor()
    }
  }
  ```
* It’s no longer possible to conform a type to the RandomNumberGenerator protocol unless it implements the requirement:
  ```swift
  mutating func next() -> UInt64
  ```
  <br/>
  Previously, the compiler would use the defaulted generic next() if one wasn’t defined, resulting in a runtime crash. The compiler now detects this error at compile time instead. (76660011)

* Inside a non-async initializer for an actor, the compiler limits the use of self. Capturing self in a closure or calling a method or computed property generates a warning, because self could escape and create a race condition before the initializer is complete. (78790369)
  ```swift
  actor A {
    var x: Int
    func tick() { self.x += 1 }
  
    init() {
      self.x = 0
      self.tick() // Warning: This use of actor 'self' can only appear in an async initializer.
                  // Note: Convenience initializers allow non-isolated use of 'self' once initialized.
  
      Task.detached { await self.tick() } // Warning: Actor 'self' can only be captured by a closure from an async initializer.
                                          // Note: Convenience initializers allow non-isolated use of 'self' once initialized.
    }
  }
  ```
  If your existing code needs to access self within the initializer, you can declare a non-async convenience init in the actor that delegates to the designated initializer, just like in a class.
  ```swift
  actor A {
    var x: Int
    func tick() { self.x += 1 }
  
    private init(v: Void) {
      self.x = 0
    }
  
    convenience init() {
      self.init(v: ())
      await self.tick() // Error: Await in non-async function.
                        // Must rely on the task to call 'tick' from this init.
      Task.detached { await self.tick() } // Closure capture is OK here.
    }
  }
  ```
* When building incrementally, the Swift driver now considers the modification time of the target of a symlink instead of the symlink itself. (78828871)

* The compiler now correctly rejects the application of generic arguments to the special Self type. (79051797)

  For example:
  ```swift
  struct Box<T> {
    // previously interpreted as a return type of Box<T>, ignoring the <Int> part;
    // now we diagnose an error with a fixit suggesting replacing `Self` with `Box`
    static func makeBox() -> Self<Int> {}
  }
  ```
* Apps that contain Swift code referencing featureIdentifier or typeIdentifier now launch in earlier OS releases. (79090498)

* The Swift standard library no longer provides a nonfunctional default implementation of the subscript(bounds: Range<Index>) accessor for Collection implementors whose SubSequence isn’t Slice. Define your code’s subscript(bounds: Range<Index>) -> SubSequence, or use Slice as your Collection’s SubSequence. (SR-14848, 79891982)

* The compiler used to erroneously accept @available annotations on enum cases with associated values that were newer than the deployment target. (80238318)

  For example:
  ```swift
  @available(macOS 12, *)
  public struct Crayon {}
  
  public enum Pen {
    case pencil
  
    @available(macOS 12, *)
    case crayon(Crayon)
  }
  ```
  <br/>
  While this worked in some cases, there was no way for the Swift runtime to perform the requisite dynamic layout needed in general, so this could cause crashes at runtime. The compiler now rejects such availability newer than the deployment target on enum cases.

* When declaring a method or function, you can declare an isolated parameter of actor type. When you call the function, the system executes it on the provided actor. isolated parameters extend the actor-isolated semantics of the self parameter of actor methods to arbitrary parameters. (SE-0313, 80907464)

  For example:
  ```swift
  actor MyActor {
    func f() { }
  }
  
  func g(actor: isolated MyActor) {
    actor.f()   // OK: This code always executes on "actor".
  }
  
  func h(actor: MyActor) async {
    g(actor: actor)        // Error: The call must be asynchronous.
      await g(actor: actor)  // OK: Hops to "actor" before calling g.
  }
  ```
  The self parameter of an actor method is implicitly isolated. The nonisolated keyword makes the self parameter no longer isolated.

### Known Issues
* Swift Concurrency requires a deployment target of macOS 12, iOS 15, tvOS 15, and watchOS 8 or newer. (70738378)

* Swift libraries may fail to build for iOS targets that use armv7. (74120874)

  Workaround: Increase the platform dependency of the package to v12 or later.

* os_activity APIs don’t track activity in Swift async code, and may produce incomplete information about that activity. (76080222)

* Swift tasks won’t have their priority escalated in response to awaiting on their handles. (76127624)

* The Swift compiler might crash when declaring an extension of a generic struct, enum, or class if the type has a where clause with a same-type requirement, and the extension has a where clause that constrains a generic parameter to a concrete type. (79570734)

* Swift libraries depending on Combine may fail to build for targets including armv7 and i386 architectures. (82183186, 82189214)

  Workaround: Use an updated version of the library that isn’t impacted (if available) or remove armv7 and i386 support (for example, increase the deployment target of the library to iOS 11 or higher).

* In macOS apps, the free function takes a non-optional argument, which might break existing code. (83133387) (FB9626044)

  Workaround: Define a wrapper for free that forwards the call to the SDK’s free only on non-optional arguments. For example:
  ```swift
  if let value = value { Darwin.free(value) }
  ```
* Availability checks in iPhone and iPad apps on a Mac with Apple silicon always return true. This causes iOS apps running in macOS 11 Big Sur to see iOS 15 APIs as available, resulting in crashes. This only affects apps available in the Mac App Store built with the “My Mac (Designed for iPhone)” or “My Mac (Designed for iPad)” run destination. It doesn’t affect Mac Catalyst apps. (83378814)

  Workaround: Use the following code to check for iOS 15 availability:
  ```swift
          if #available(iOS 15, *), ProcessInfo.processInfo.operatingSystemVersion.majorVersion >= 15 {
  ```
### Deprecations
* Type names are no longer allowed as an argument to a subscript parameter that expects a metatype type. (61749633, 78029595)

  For example:
  ```swift
  struct MyValue {
  }
  
  struct MyStruct {
    subscript(a: MyValue.Type) -> Int { get { ... } }
  }
  
  func test(obj: MyStruct) {
    let _ = obj[MyValue]
  }
  ```
  
## Swift Packages
### New Features
* Root packages and branch-based package dependencies can now use unsafeFlags in their target settings. (53679279)

* Swift packages can now declare a deployment target for Mac Catalyst, and can now specify Mac Catalyst as a platform in build conditions.

* Build conditions for macOS no longer apply to Mac Catalyst when the package declares a tools version of 5.5 or later. (60376383)

* Swift Packages now supports DriverKit as a platform. (66656190)

* Xcode now suggests packages from your added collections when you attempt to import a module that isn’t yet available locally. (69801540)

* Curated collections of packages can now be added in the Add Packages sheet. (70259327)

* Unit tests can now directly test executable targets. To do this, configure the unit test to depend on the executable target and import the module, exactly as for any library module. Swift Package Manager still builds a product in this case, so that the unit test can also test the executable itself using Process(). (75198161)

### Resolved Issues
* Improved the diagnostic information that Swift Package Manager returns when file paths in package manifests are invalid. Specifying a nonexistent or invalid path for a source file or resource now produces an error. (60708059, 60745311, 64176116)

* Improved target-based dependency resolution. A more intuitive .product(name:, package:) syntax is now accepted, where package is the package name as defined by the package URL. (65048461)

* Linking Swift packages from application extension targets or watchOS applications no longer emits unresolvable warnings about linking to libraries not safe for use in application extensions. This means that code referencing APIs annotated as unavailable for use in app extensions must now themselves be annotated as unavailable for use in application extensions, in order to allow that code to be used in both apps and app extensions. (66928265)

* Fixed an issue that caused debug symbols to be removed from libraries that were built from Swift packages, making crash logs downloaded from TestFlight difficult to debug if their contents referenced those libraries. (67310056)

* Xcode no longer passes testing search paths to all targets.

  With this change, Swift package library targets (but not test targets) which import XCTest or StoreKitTest must now explicitly reference those frameworks in the package manifest using linker settings:
  ```
  linkerSettings: [.linkedFramework("XCTest")]
  ```
  <br/>
  This update doesn’t apply to test targets, which can still import test frameworks by default without any explicit mention in linker settings. (75061901)

* Fixed an issue where resolution of packages with binary dependencies failed to extract the binary archive. (77011310) (FB9085487)

* You can now remove recently used packages.(77056983, 79407145)

* Xcode no longer repeatedly reloads the package if you customize settings to store Xcode’s Derived Data directory inside the package source directory. (77208577, 78143803) (FB9109834)

* You can now access the Add Packages panel for Xcode windows hosting a package, and copy package dependencies to the clipboard. (79023046)

### Known Issues
* Using Swift packages with binary targets may result in a “no such module” error when attempting to import the module of a binary target. (77465707)

## Swift Refactoring
### New Features
* New refactorings help migrate to async code. “Convert Call to Async Alternative” is available on calls that take a completion handler as their last argument, and refactors them to use the new async language features, assuming that an async equivalent of that function already exists. “Convert Function to Async” applies to any sync function, adds the async keyword to the signature, translates the completion handler argument (and calls to it) if there is one, and converts calls to async where possible. “Add Async Alternative” is similar to “Convert Function to Async” but adds the async function rather than converting the synchronous one. (68254700)

* You can now apply a new “Add Async Wrapper” refactoring action to a function with a completion handler. When you apply this wrapper, a new async alternative function is created that forwards to the original function. (77802486)

## Templates
### Resolved Issues
* Projects created from several templates no longer require configuration files such as entitlements and Info.plist files. Configure common fields in the target’s Info tab, and build settings in the project editor. These files are added to the project when additional fields are used. (68254857)

* New projects created with Xcode 13 use a new project version. Using the new projects with an older version of Xcode requires changing the project version in the File inspector along with manual migration of the configuration settings for Info.plist and entitlements you can now specify in the target build settings. (77344653)

## Testing
### New Features
* The Source Editor and Test Navigator have two new variants of the Run Test action that run a test selection without building. This is supported for a single test execution or repeated test executions. The Product > Perform Action submenu has a new command for rerunning the last test action without rebuilding. (13486284)

* You can now customize how a performance test’s custom metric’s measurements should be compared against a set baseline, using the XCTPerformanceMeasurementPolarity enum. This customization includes marking measurements as preferring them to be smaller (default), unspecified, or larger when compared against the baseline. (49493218)

* XCTest now has the ability to synthesize pointer interactions in UI tests on supported iOS devices. (56389548)

* Xcode now collects code coverage data for processes that crash while running tests. (58496759)

* Performance XCTests now support measuring CPU usage (XCTCPUMetric), disk writes (XCTStorageMetric), and memory usage (XCTMemoryMetric) for application launches. (61112495)

* xcodebuild has a new option -enablePerformanceTestsDiagnostics YES that collects diagnostics for Performance XCTests. The option collects a ktrace file for non-XCTMemoryMetrics, and a series of memory graphs for XCTMemoryMetrics. xcodebuild attaches diagnostics to the generated xcresult bundle. Note that memory graph collection isn’t available in simulated devices. (64495534)

* Test timeouts are now enabled by default in all newly-created test plans. Test plans created by converting a scheme require manually enabling test timeouts to preserve the existing behavior. (64861872)

* User Interface Tests now support using the swipeUp, swipeDown, swipeLeft, and swipeRight family of methods in macOS. (65229961)

* Performance tests now support collecting glitch metrics when using the XCTOSSignpostMetric for an animation os_signpost interval in macOS. (69345790)

* XCTest now supports test repetition. (69470788, 71428753, 72078437)

* There are three test repetition modes. Up Until Maximum Repetitions repeats a test up to the specified maximum regardless of the status. Until Failure repeats a test until it fails. Retry on Failure retries a test until it succeeds. Enable test repetition in your test plan, xcodebuild, or by running your test from the test diamond by Control-clicking and selecting Run <testName> Repeatedly to bring up the test repetition dialog.

* When using xcodebuild, pass -test-iterations with a number to run a test a fixed number of times, or combine it with -retry-tests-on-failure or -run-tests-until-failure to use one of the other stopping conditions. For example, to run your test with repetition from the command line, start with the base xcodebuild command to run your test, and add the flags -test-iterations set to 100 and -run-tests-until-failure:

  ```
  xcodebuild test -project MyProject.xcodeproj -scheme MyProject -destination 'platform=iOS Simulator,name=iPhone 12,OS=15.0' -test-iterations 100 -run-tests-until-failure
  ```
  
  In a Test Plan, configure your test plan to use test repetitions and go to the test plan. Click Configurations, then under Test Execution, set Test Repetition Mode and also set Maximum Test Repetitions. The options for Test Repetition Mode are: Until Failure, Retry on Failure, and Up until Maximum Repetitions. Maximum Test Repetitions must be a positive integer. Setting test repetitions with xcodebuild or the test diamond overrides any test plan setting.

* A new transparent screen overlay indicates the activity while automation is running, and displays text describing how to stop the automation. If you interact with the device while automation is running, the overlay fades away to allow you to better see the screen contents. This new behavior is present in macOS 12, iOS 15, tvOS 15, and watchOS 8.

  In macOS, or when using automation on devices with a password, you must run the automation from an admin account, and must authenticate to authorize the automation. This authorization is cached for eight hours. You no longer need to authorize the Xcode Helper app to use Accessibility when running in macOS 12. (71297492)

* XCTest now supports resetting the authorization status for the protected resource “user tracking” from the App Tracking Transparency framework. (72452504)

* Test methods written in Swift may be marked async or async throws to allow calling and awaiting results from async APIs, as part of the Swift Concurrency language feature. This reduces the need to explicitly wait on an XCTestExpectation and helps prevent concurrency-related bugs in tests. (72600990)

  For example:
  ```swift
  // An example async API to test.
  func chopVegetables() async throws -> [Vegetable]
  
  func test_chopVegetables() async throws {
      let vegetables = try await chopVegetables()
      XCTAssertEqual(vegetables.count, 3)
  }
  ```
* XCTestCase now includes an addTeardownBlock method overload whose closure parameter is async throws, which allows teardown blocks to natively call throwing APIs or await the results of async APIs. (73156219)

* xcodebuild now supports passing certain environment variables to test runner processes. In the environment where xcodebuild is invoked, prefix any variable with TEST_RUNNER_ to pass that variable (with the prefix stripped) to XCTest test runner processes. For example, running env TEST_RUNNER_Foo=Bar xcodebuild test ... causes the environment variable Foo=Bar to be set in the test runner’s environment. (74104870)

  Additionally, existing variables may be modified using the special token __CURRENT_VALUE__ to represent their current value. For example, TEST_RUNNER_Foo=__CURRENT_VALUE__:Bar appends the string :Bar to any existing value of Foo. Note that only test runner processes receive these environment variables. To set them in apps targeted by UI tests, customize the XCUIApplication.launchEnvironment dictionary prior to launching the app.

* The XCTExpectFailure function now includes Swift overloads for customizing certain options without needing to create an XCTExpectedFailure.Options instance, such as strict, enabled, and issueMatcher. (76663874)

  Here are two examples:
  ```swift
  // This test declares an expected failure in the remainder of the test method body, with strict behavior disabled:
  func test_disablingStrict() {
      XCTExpectFailure("https://dev.myco.com/bugs/1234 (Something is non-deterministic)", strict: false)
      // ...Test something expected to fail...
  }

  // This test declares an expected failure within the scope of its first block parameter, along with a custom issue matcher in the second parameter:
  func test_customIssueMatcher() {
      XCTExpectFailure("...") {
          // ...Test something expected to fail...
      } issueMatcher: { issue in
          issue.compactDescription.contains("errorCode: 999")
      }
  }
  ```
* XCTest now has the ability to synthesize Digital Crown rotation in watchOS UI tests. (76816883)

* XCTest now includes async throws overloads of the setUp and tearDown instance methods. XCTest invokes the async setUp overload first before setUpWithError and non-async setUp, but it invokes async tearDown last, after non-async tearDown and tearDownWithError. XCTest records errors thrown by these new overloads as issues. (77610427)

* Tests can now call XCTestCase.expectation(description:) — as well as other XCTestCase APIs that return an XCTestExpectation — from any thread. This removes a previous requirement that tests call these APIs from the main thread, and it allows existing tests using them to adopt async without requiring @MainActor. (79163972)

### Resolved Issues
* Improved the performance of working in large workspaces that use many test plans. (56445700)

* XCTest now supports resetting the authorization status of additional protected resources: Network Volumes, Removable Volumes, Apple Events, and Focus. (64937038) (FB7828459)

### Known Issues
* Attempting to run unit or UI tests for Watch apps crashes Xcode when the Run scheme action’s executable is set to None. (74928871)

  Workaround: Set the Run scheme action’s executable to a valid WatchKit app target built by the scheme.

* UI Test Recording fails to generate code for iOS Simulator targets if recording starts after code execution has stopped at a user-defined breakpoint. (77924295)

  Workaround: With no breakpoint set, place your cursor within a test method and press the record button.

* UI Test Recording fails to generate code for targets in a simulated watchOS device. (78024399)

* UI Test Recording fails on watchOS devices, and presents an alert saying “Unable to install <watch app name>.” (78024956)

* Swift async test methods aren’t executed on the main queue as non-async test methods are. (78176413)

  Workaround: Add the @MainActor attribute to affected async test methods or classes.

* UI tests may time out and display the error “Timed out while requesting automation session for <bundle ID>” while starting in watchOS and tvOS simulators that weren’t already booted when the test action initiated. (78475446)

* You can only call XCTest UI automation APIs (such as XCUIApplication) from the main thread. XCTest UI automation APIs might fail when used in async Swift test methods that don’t include @MainActor. (80386414)

  Workaround: Include @MainActor on affected test methods or classes.



[<i class="fas fa-link"></i> xcode 13.0 whats new
](https://developer.apple.com/kr/xcode/whats-new/){:target="_blank"}  
[<i class="fas fa-link"></i> xcode-13-release-notes
](https://developer.apple.com/documentation/xcode-release-notes/xcode-13-release-notes){:target="_blank"}  
